METHOD: System.Int32 VSharp.CSharpUtils.TryCatch.SafeFunc(System.Int32)
RESULT: 1
HEAP:
1 ==> STRUCT VSharp.CSharpUtils.TryCatch[
	]
VSharp.CSharpUtils.TryCatch ==> STRUCT VSharp.CSharpUtils.TryCatch[
	]
METHOD: System.Boolean VSharp.CSharpUtils.TryCatch.MakeOdd(System.Int32)
RESULT: !(0 == n % 2) & !(n <= 0) & 1 == n % 2 | !(n <= 0) & (1 + n) % 2 == 1 & 0 == n % 2 | (-n + 1) % 2 == 1 & n <= 0 | 0 == n
HEAP:
1 ==> STRUCT VSharp.CSharpUtils.TryCatch[
	]
2 ==> STRUCT System.ArgumentException[
	| System.ArgumentException.m_paramName ~> null
	| System.Exception._HResult ~> -2147024809
	| System.Exception._className ~> null
	| System.Exception._data ~> null
	| System.Exception._dynamicMethods ~> null
	| System.Exception._helpURL ~> null
	| System.Exception._innerException ~> null
	| System.Exception._message ~> null
	| System.Exception._remoteStackIndex ~> 0
	| System.Exception._remoteStackTraceString ~> null
	| System.Exception._safeSerializationManager ~> null
	| System.Exception._source ~> null
	| System.Exception._stackTrace ~> null
	| System.Exception._stackTraceString ~> null
	| System.Exception.captured_traces ~> null
	| System.Exception.native_trace_ips ~> null]
3 ==> STRUCT System.Object[
	]
4 ==> STRUCT System.InvalidOperationException[
	| System.Exception._HResult ~> -2146233079
	| System.Exception._className ~> null
	| System.Exception._data ~> null
	| System.Exception._dynamicMethods ~> null
	| System.Exception._helpURL ~> null
	| System.Exception._innerException ~> null
	| System.Exception._message ~> null
	| System.Exception._remoteStackIndex ~> 0
	| System.Exception._remoteStackTraceString ~> null
	| System.Exception._safeSerializationManager ~> null
	| System.Exception._source ~> null
	| System.Exception._stackTrace ~> null
	| System.Exception._stackTraceString ~> null
	| System.Exception.captured_traces ~> null
	| System.Exception.native_trace_ips ~> null]
5 ==> STRUCT System.Exception[
	| System.Exception._HResult ~> -2146233088
	| System.Exception._className ~> null
	| System.Exception._data ~> null
	| System.Exception._dynamicMethods ~> null
	| System.Exception._helpURL ~> null
	| System.Exception._innerException ~> null
	| System.Exception._message ~> Not odd!
	| System.Exception._remoteStackIndex ~> 0
	| System.Exception._remoteStackTraceString ~> null
	| System.Exception._safeSerializationManager ~> (HeapRef 7)
	| System.Exception._source ~> null
	| System.Exception._stackTrace ~> null
	| System.Exception._stackTraceString ~> null
	| System.Exception.captured_traces ~> null
	| System.Exception.native_trace_ips ~> null]
6 ==> STRUCT System.Runtime.Serialization.SafeSerializationManager[
	| System.Runtime.Serialization.SafeSerializationManager.m_realObject ~> null
	| System.Runtime.Serialization.SafeSerializationManager.m_realType ~> null
	| System.Runtime.Serialization.SafeSerializationManager.m_savedSerializationInfo ~> null
	| System.Runtime.Serialization.SafeSerializationManager.m_serializedStates ~> null]
7 ==> STRUCT System.Runtime.Serialization.SafeSerializationManager[
	| System.Runtime.Serialization.SafeSerializationManager.m_realObject ~> null
	| System.Runtime.Serialization.SafeSerializationManager.m_realType ~> null
	| System.Runtime.Serialization.SafeSerializationManager.m_savedSerializationInfo ~> null
	| System.Runtime.Serialization.SafeSerializationManager.m_serializedStates ~> null]
System.ArgumentException ==> STRUCT System.ArgumentException[
	]
System.Exception ==> STRUCT System.Exception[
	| System.Exception._COMPlusExceptionCode ~> -532462766
	| System.Exception.s_EDILock ~> (HeapRef 3)]
System.InvalidOperationException ==> STRUCT System.InvalidOperationException[
	]
System.Object ==> STRUCT System.Object[
	]
System.Runtime.Serialization.SafeSerializationManager ==> STRUCT System.Runtime.Serialization.SafeSerializationManager[
	| System.Runtime.Serialization.SafeSerializationManager.RealTypeSerializationName ~> CLR_SafeSerializationManager_RealType]
VSharp.CSharpUtils.TryCatch ==> STRUCT VSharp.CSharpUtils.TryCatch[
	]
METHOD: System.Int32 VSharp.CSharpUtils.Tests.Arithmetics.ArithmeticsMethod1(System.Int32, System.Int32)
RESULT: UNION[
	| !(0 == m) ~> 7 + n
	| 0 == m ~> <ERROR: System.DivideByZeroException: Attempted to divide by zero.>]
HEAP:
VSharp.CSharpUtils.Tests.Arithmetics ==> STRUCT VSharp.CSharpUtils.Tests.Arithmetics[
	]
METHOD: System.Int32 VSharp.CSharpUtils.Tests.Arithmetics.ArithmeticsMethod2(System.Int32, System.Int32)
RESULT: 0
HEAP:
VSharp.CSharpUtils.Tests.Arithmetics ==> STRUCT VSharp.CSharpUtils.Tests.Arithmetics[
	]
METHOD: System.Int32 VSharp.CSharpUtils.Tests.Arithmetics.ArithmeticsMethod3(System.Int32, System.Int32, System.Int32)
RESULT: -11 + c
HEAP:
VSharp.CSharpUtils.Tests.Arithmetics ==> STRUCT VSharp.CSharpUtils.Tests.Arithmetics[
	]
METHOD: System.Int32 VSharp.CSharpUtils.Tests.Arithmetics.ArithmeticsMethod4(System.Int32, System.Int32)
RESULT: UNION[
	| !(0 == m * m * m) ~> -126826 + n + n + n + n + n + n
	| 0 == m * m * m ~> <ERROR: System.DivideByZeroException: Attempted to divide by zero.>]
HEAP:
VSharp.CSharpUtils.Tests.Arithmetics ==> STRUCT VSharp.CSharpUtils.Tests.Arithmetics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Arithmetics.IncrementsWorkCorrect(System.Int32)
RESULT: True
HEAP:
VSharp.CSharpUtils.Tests.Arithmetics ==> STRUCT VSharp.CSharpUtils.Tests.Arithmetics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Arithmetics.Decreasing(System.Int32)
RESULT: True
HEAP:
VSharp.CSharpUtils.Tests.Arithmetics ==> STRUCT VSharp.CSharpUtils.Tests.Arithmetics[
	]
METHOD: System.Int32 VSharp.CSharpUtils.Tests.Arithmetics.CheckedUnchecked(System.Int32, System.Int32, System.Int32, System.Int32, System.Int32, System.Int32, System.Int32, System.Int32, System.Int32, System.Int32)
RESULT: checked(x0 + unchecked(checked(x2 + x3 + x4) + x1) + unchecked(-(x6 * x7) + x5))
HEAP:
VSharp.CSharpUtils.Tests.Arithmetics ==> STRUCT VSharp.CSharpUtils.Tests.Arithmetics[
	]
METHOD: System.Double VSharp.CSharpUtils.Tests.Arithmetics.LogMethod1(System.Double)
RESULT: log(x)
HEAP:
1 ==> [| 0: 1; 1: 10; 10: 10000000000; 11: 100000000000; 12: 1000000000000; 13: 10000000000000; 14: 100000000000000; 15: 1E+15; 2: 100; 3: 1000; 4: 10000; 5: 100000; 6: 1000000; 7: 10000000; 8: 100000000; 9: 1000000000 ... 16 ... |]
System.Math ==> STRUCT System.Math[
	| System.Math.E ~> 2.71828182845905
	| System.Math.PI ~> 3.14159265358979
	| System.Math.doubleRoundLimit ~> 1E+16
	| System.Math.maxRoundingDigits ~> 15
	| System.Math.roundPower10Double ~> (HeapRef 1)]
VSharp.CSharpUtils.Tests.Arithmetics ==> STRUCT VSharp.CSharpUtils.Tests.Arithmetics[
	]
METHOD: System.Double VSharp.CSharpUtils.Tests.Arithmetics.LogMethod2(System.Double, System.Double)
RESULT: log(x + y)
HEAP:
1 ==> [| 0: 1; 1: 10; 10: 10000000000; 11: 100000000000; 12: 1000000000000; 13: 10000000000000; 14: 100000000000000; 15: 1E+15; 2: 100; 3: 1000; 4: 10000; 5: 100000; 6: 1000000; 7: 10000000; 8: 100000000; 9: 1000000000 ... 16 ... |]
System.Math ==> STRUCT System.Math[
	| System.Math.E ~> 2.71828182845905
	| System.Math.PI ~> 3.14159265358979
	| System.Math.doubleRoundLimit ~> 1E+16
	| System.Math.maxRoundingDigits ~> 15
	| System.Math.roundPower10Double ~> (HeapRef 1)]
VSharp.CSharpUtils.Tests.Arithmetics ==> STRUCT VSharp.CSharpUtils.Tests.Arithmetics[
	]
METHOD: System.Double VSharp.CSharpUtils.Tests.Arithmetics.LogMethod3()
RESULT: 0
HEAP:
1 ==> [| 0: 1; 1: 10; 10: 10000000000; 11: 100000000000; 12: 1000000000000; 13: 10000000000000; 14: 100000000000000; 15: 1E+15; 2: 100; 3: 1000; 4: 10000; 5: 100000; 6: 1000000; 7: 10000000; 8: 100000000; 9: 1000000000 ... 16 ... |]
System.Math ==> STRUCT System.Math[
	| System.Math.E ~> 2.71828182845905
	| System.Math.PI ~> 3.14159265358979
	| System.Math.doubleRoundLimit ~> 1E+16
	| System.Math.maxRoundingDigits ~> 15
	| System.Math.roundPower10Double ~> (HeapRef 1)]
VSharp.CSharpUtils.Tests.Arithmetics ==> STRUCT VSharp.CSharpUtils.Tests.Arithmetics[
	]
METHOD: System.Double VSharp.CSharpUtils.Tests.Arithmetics.LogMethod4(System.Double)
RESULT: log(1 + log(x))
HEAP:
1 ==> [| 0: 1; 1: 10; 10: 10000000000; 11: 100000000000; 12: 1000000000000; 13: 10000000000000; 14: 100000000000000; 15: 1E+15; 2: 100; 3: 1000; 4: 10000; 5: 100000; 6: 1000000; 7: 10000000; 8: 100000000; 9: 1000000000 ... 16 ... |]
System.Math ==> STRUCT System.Math[
	| System.Math.E ~> 2.71828182845905
	| System.Math.PI ~> 3.14159265358979
	| System.Math.doubleRoundLimit ~> 1E+16
	| System.Math.maxRoundingDigits ~> 15
	| System.Math.roundPower10Double ~> (HeapRef 1)]
VSharp.CSharpUtils.Tests.Arithmetics ==> STRUCT VSharp.CSharpUtils.Tests.Arithmetics[
	]
METHOD: System.Double VSharp.CSharpUtils.Tests.Arithmetics.LogMethod5()
RESULT: -Infinity
HEAP:
1 ==> [| 0: 1; 1: 10; 10: 10000000000; 11: 100000000000; 12: 1000000000000; 13: 10000000000000; 14: 100000000000000; 15: 1E+15; 2: 100; 3: 1000; 4: 10000; 5: 100000; 6: 1000000; 7: 10000000; 8: 100000000; 9: 1000000000 ... 16 ... |]
System.Math ==> STRUCT System.Math[
	| System.Math.E ~> 2.71828182845905
	| System.Math.PI ~> 3.14159265358979
	| System.Math.doubleRoundLimit ~> 1E+16
	| System.Math.maxRoundingDigits ~> 15
	| System.Math.roundPower10Double ~> (HeapRef 1)]
VSharp.CSharpUtils.Tests.Arithmetics ==> STRUCT VSharp.CSharpUtils.Tests.Arithmetics[
	]
METHOD: System.Double VSharp.CSharpUtils.Tests.Arithmetics.LogMethod6()
RESULT: NaN
HEAP:
1 ==> [| 0: 1; 1: 10; 10: 10000000000; 11: 100000000000; 12: 1000000000000; 13: 10000000000000; 14: 100000000000000; 15: 1E+15; 2: 100; 3: 1000; 4: 10000; 5: 100000; 6: 1000000; 7: 10000000; 8: 100000000; 9: 1000000000 ... 16 ... |]
System.Math ==> STRUCT System.Math[
	| System.Math.E ~> 2.71828182845905
	| System.Math.PI ~> 3.14159265358979
	| System.Math.doubleRoundLimit ~> 1E+16
	| System.Math.maxRoundingDigits ~> 15
	| System.Math.roundPower10Double ~> (HeapRef 1)]
VSharp.CSharpUtils.Tests.Arithmetics ==> STRUCT VSharp.CSharpUtils.Tests.Arithmetics[
	]
METHOD: System.Double VSharp.CSharpUtils.Tests.Arithmetics.LogMethod7(System.Double)
RESULT: UNION[
	| !(x < 0) ~> log(x)
	| x < 0 ~> log(-x)]
HEAP:
1 ==> [| 0: 1; 1: 10; 10: 10000000000; 11: 100000000000; 12: 1000000000000; 13: 10000000000000; 14: 100000000000000; 15: 1E+15; 2: 100; 3: 1000; 4: 10000; 5: 100000; 6: 1000000; 7: 10000000; 8: 100000000; 9: 1000000000 ... 16 ... |]
System.Math ==> STRUCT System.Math[
	| System.Math.E ~> 2.71828182845905
	| System.Math.PI ~> 3.14159265358979
	| System.Math.doubleRoundLimit ~> 1E+16
	| System.Math.maxRoundingDigits ~> 15
	| System.Math.roundPower10Double ~> (HeapRef 1)]
VSharp.CSharpUtils.Tests.Arithmetics ==> STRUCT VSharp.CSharpUtils.Tests.Arithmetics[
	]
METHOD: System.Double VSharp.CSharpUtils.Tests.Arithmetics.SqrtMethod1(System.Double)
RESULT: sqrt(x)
HEAP:
1 ==> [| 0: 1; 1: 10; 10: 10000000000; 11: 100000000000; 12: 1000000000000; 13: 10000000000000; 14: 100000000000000; 15: 1E+15; 2: 100; 3: 1000; 4: 10000; 5: 100000; 6: 1000000; 7: 10000000; 8: 100000000; 9: 1000000000 ... 16 ... |]
System.Math ==> STRUCT System.Math[
	| System.Math.E ~> 2.71828182845905
	| System.Math.PI ~> 3.14159265358979
	| System.Math.doubleRoundLimit ~> 1E+16
	| System.Math.maxRoundingDigits ~> 15
	| System.Math.roundPower10Double ~> (HeapRef 1)]
VSharp.CSharpUtils.Tests.Arithmetics ==> STRUCT VSharp.CSharpUtils.Tests.Arithmetics[
	]
METHOD: System.Double VSharp.CSharpUtils.Tests.Arithmetics.SqrtMethod2()
RESULT: 2
HEAP:
1 ==> [| 0: 1; 1: 10; 10: 10000000000; 11: 100000000000; 12: 1000000000000; 13: 10000000000000; 14: 100000000000000; 15: 1E+15; 2: 100; 3: 1000; 4: 10000; 5: 100000; 6: 1000000; 7: 10000000; 8: 100000000; 9: 1000000000 ... 16 ... |]
System.Math ==> STRUCT System.Math[
	| System.Math.E ~> 2.71828182845905
	| System.Math.PI ~> 3.14159265358979
	| System.Math.doubleRoundLimit ~> 1E+16
	| System.Math.maxRoundingDigits ~> 15
	| System.Math.roundPower10Double ~> (HeapRef 1)]
VSharp.CSharpUtils.Tests.Arithmetics ==> STRUCT VSharp.CSharpUtils.Tests.Arithmetics[
	]
METHOD: System.Double VSharp.CSharpUtils.Tests.Arithmetics.SqrtMethod3(System.Double)
RESULT: UNION[
	| !(x < 0) ~> sqrt(x)
	| x < 0 ~> sqrt(-x)]
HEAP:
1 ==> [| 0: 1; 1: 10; 10: 10000000000; 11: 100000000000; 12: 1000000000000; 13: 10000000000000; 14: 100000000000000; 15: 1E+15; 2: 100; 3: 1000; 4: 10000; 5: 100000; 6: 1000000; 7: 10000000; 8: 100000000; 9: 1000000000 ... 16 ... |]
System.Math ==> STRUCT System.Math[
	| System.Math.E ~> 2.71828182845905
	| System.Math.PI ~> 3.14159265358979
	| System.Math.doubleRoundLimit ~> 1E+16
	| System.Math.maxRoundingDigits ~> 15
	| System.Math.roundPower10Double ~> (HeapRef 1)]
VSharp.CSharpUtils.Tests.Arithmetics ==> STRUCT VSharp.CSharpUtils.Tests.Arithmetics[
	]
METHOD: System.Double VSharp.CSharpUtils.Tests.Arithmetics.SqrtMethod4()
RESULT: NaN
HEAP:
1 ==> [| 0: 1; 1: 10; 10: 10000000000; 11: 100000000000; 12: 1000000000000; 13: 10000000000000; 14: 100000000000000; 15: 1E+15; 2: 100; 3: 1000; 4: 10000; 5: 100000; 6: 1000000; 7: 10000000; 8: 100000000; 9: 1000000000 ... 16 ... |]
System.Math ==> STRUCT System.Math[
	| System.Math.E ~> 2.71828182845905
	| System.Math.PI ~> 3.14159265358979
	| System.Math.doubleRoundLimit ~> 1E+16
	| System.Math.maxRoundingDigits ~> 15
	| System.Math.roundPower10Double ~> (HeapRef 1)]
VSharp.CSharpUtils.Tests.Arithmetics ==> STRUCT VSharp.CSharpUtils.Tests.Arithmetics[
	]
METHOD: System.Double VSharp.CSharpUtils.Tests.Arithmetics.ExpMethod1()
RESULT: 1
HEAP:
1 ==> [| 0: 1; 1: 10; 10: 10000000000; 11: 100000000000; 12: 1000000000000; 13: 10000000000000; 14: 100000000000000; 15: 1E+15; 2: 100; 3: 1000; 4: 10000; 5: 100000; 6: 1000000; 7: 10000000; 8: 100000000; 9: 1000000000 ... 16 ... |]
System.Math ==> STRUCT System.Math[
	| System.Math.E ~> 2.71828182845905
	| System.Math.PI ~> 3.14159265358979
	| System.Math.doubleRoundLimit ~> 1E+16
	| System.Math.maxRoundingDigits ~> 15
	| System.Math.roundPower10Double ~> (HeapRef 1)]
VSharp.CSharpUtils.Tests.Arithmetics ==> STRUCT VSharp.CSharpUtils.Tests.Arithmetics[
	]
METHOD: System.Double VSharp.CSharpUtils.Tests.Arithmetics.ExpMethod2(System.Double)
RESULT: exp(x)
HEAP:
1 ==> [| 0: 1; 1: 10; 10: 10000000000; 11: 100000000000; 12: 1000000000000; 13: 10000000000000; 14: 100000000000000; 15: 1E+15; 2: 100; 3: 1000; 4: 10000; 5: 100000; 6: 1000000; 7: 10000000; 8: 100000000; 9: 1000000000 ... 16 ... |]
System.Math ==> STRUCT System.Math[
	| System.Math.E ~> 2.71828182845905
	| System.Math.PI ~> 3.14159265358979
	| System.Math.doubleRoundLimit ~> 1E+16
	| System.Math.maxRoundingDigits ~> 15
	| System.Math.roundPower10Double ~> (HeapRef 1)]
VSharp.CSharpUtils.Tests.Arithmetics ==> STRUCT VSharp.CSharpUtils.Tests.Arithmetics[
	]
METHOD: System.Double VSharp.CSharpUtils.Tests.Arithmetics.PowMethod1(System.Double)
RESULT: 1
HEAP:
1 ==> [| 0: 1; 1: 10; 10: 10000000000; 11: 100000000000; 12: 1000000000000; 13: 10000000000000; 14: 100000000000000; 15: 1E+15; 2: 100; 3: 1000; 4: 10000; 5: 100000; 6: 1000000; 7: 10000000; 8: 100000000; 9: 1000000000 ... 16 ... |]
System.Math ==> STRUCT System.Math[
	| System.Math.E ~> 2.71828182845905
	| System.Math.PI ~> 3.14159265358979
	| System.Math.doubleRoundLimit ~> 1E+16
	| System.Math.maxRoundingDigits ~> 15
	| System.Math.roundPower10Double ~> (HeapRef 1)]
VSharp.CSharpUtils.Tests.Arithmetics ==> STRUCT VSharp.CSharpUtils.Tests.Arithmetics[
	]
METHOD: System.Double VSharp.CSharpUtils.Tests.Arithmetics.PowMethod2(System.Double)
RESULT: 1
HEAP:
1 ==> [| 0: 1; 1: 10; 10: 10000000000; 11: 100000000000; 12: 1000000000000; 13: 10000000000000; 14: 100000000000000; 15: 1E+15; 2: 100; 3: 1000; 4: 10000; 5: 100000; 6: 1000000; 7: 10000000; 8: 100000000; 9: 1000000000 ... 16 ... |]
System.Math ==> STRUCT System.Math[
	| System.Math.E ~> 2.71828182845905
	| System.Math.PI ~> 3.14159265358979
	| System.Math.doubleRoundLimit ~> 1E+16
	| System.Math.maxRoundingDigits ~> 15
	| System.Math.roundPower10Double ~> (HeapRef 1)]
VSharp.CSharpUtils.Tests.Arithmetics ==> STRUCT VSharp.CSharpUtils.Tests.Arithmetics[
	]
METHOD: System.Double VSharp.CSharpUtils.Tests.Arithmetics.PowMethod3()
RESULT: 25
HEAP:
1 ==> [| 0: 1; 1: 10; 10: 10000000000; 11: 100000000000; 12: 1000000000000; 13: 10000000000000; 14: 100000000000000; 15: 1E+15; 2: 100; 3: 1000; 4: 10000; 5: 100000; 6: 1000000; 7: 10000000; 8: 100000000; 9: 1000000000 ... 16 ... |]
System.Math ==> STRUCT System.Math[
	| System.Math.E ~> 2.71828182845905
	| System.Math.PI ~> 3.14159265358979
	| System.Math.doubleRoundLimit ~> 1E+16
	| System.Math.maxRoundingDigits ~> 15
	| System.Math.roundPower10Double ~> (HeapRef 1)]
VSharp.CSharpUtils.Tests.Arithmetics ==> STRUCT VSharp.CSharpUtils.Tests.Arithmetics[
	]
METHOD: System.Double VSharp.CSharpUtils.Tests.Arithmetics.PowMethod4(System.Double, System.Double)
RESULT: pow(x, y)
HEAP:
1 ==> [| 0: 1; 1: 10; 10: 10000000000; 11: 100000000000; 12: 1000000000000; 13: 10000000000000; 14: 100000000000000; 15: 1E+15; 2: 100; 3: 1000; 4: 10000; 5: 100000; 6: 1000000; 7: 10000000; 8: 100000000; 9: 1000000000 ... 16 ... |]
System.Math ==> STRUCT System.Math[
	| System.Math.E ~> 2.71828182845905
	| System.Math.PI ~> 3.14159265358979
	| System.Math.doubleRoundLimit ~> 1E+16
	| System.Math.maxRoundingDigits ~> 15
	| System.Math.roundPower10Double ~> (HeapRef 1)]
VSharp.CSharpUtils.Tests.Arithmetics ==> STRUCT VSharp.CSharpUtils.Tests.Arithmetics[
	]
METHOD: System.Double VSharp.CSharpUtils.Tests.Arithmetics.PowMethod5(System.Double)
RESULT: UNION[
	| !(x < 0) ~> pow(x, 2)
	| x < 0 ~> pow(-x, 2)]
HEAP:
1 ==> [| 0: 1; 1: 10; 10: 10000000000; 11: 100000000000; 12: 1000000000000; 13: 10000000000000; 14: 100000000000000; 15: 1E+15; 2: 100; 3: 1000; 4: 10000; 5: 100000; 6: 1000000; 7: 10000000; 8: 100000000; 9: 1000000000 ... 16 ... |]
System.Math ==> STRUCT System.Math[
	| System.Math.E ~> 2.71828182845905
	| System.Math.PI ~> 3.14159265358979
	| System.Math.doubleRoundLimit ~> 1E+16
	| System.Math.maxRoundingDigits ~> 15
	| System.Math.roundPower10Double ~> (HeapRef 1)]
VSharp.CSharpUtils.Tests.Arithmetics ==> STRUCT VSharp.CSharpUtils.Tests.Arithmetics[
	]
METHOD: System.Double VSharp.CSharpUtils.Tests.Arithmetics.PowMethod6(System.Double)
RESULT: UNION[
	| !(x < 0) ~> pow(x, x)
	| !(x < 8) & x < 0 ~> pow(-x, -x)
	| x < 0 & x < 8 ~> pow(-x, x)]
HEAP:
1 ==> [| 0: 1; 1: 10; 10: 10000000000; 11: 100000000000; 12: 1000000000000; 13: 10000000000000; 14: 100000000000000; 15: 1E+15; 2: 100; 3: 1000; 4: 10000; 5: 100000; 6: 1000000; 7: 10000000; 8: 100000000; 9: 1000000000 ... 16 ... |]
System.Math ==> STRUCT System.Math[
	| System.Math.E ~> 2.71828182845905
	| System.Math.PI ~> 3.14159265358979
	| System.Math.doubleRoundLimit ~> 1E+16
	| System.Math.maxRoundingDigits ~> 15
	| System.Math.roundPower10Double ~> (HeapRef 1)]
VSharp.CSharpUtils.Tests.Arithmetics ==> STRUCT VSharp.CSharpUtils.Tests.Arithmetics[
	]
METHOD: System.Double VSharp.CSharpUtils.Tests.Arithmetics.PowMethod7(System.Double, System.Double)
RESULT: x + y
HEAP:
1 ==> [| 0: 1; 1: 10; 10: 10000000000; 11: 100000000000; 12: 1000000000000; 13: 10000000000000; 14: 100000000000000; 15: 1E+15; 2: 100; 3: 1000; 4: 10000; 5: 100000; 6: 1000000; 7: 10000000; 8: 100000000; 9: 1000000000 ... 16 ... |]
System.Math ==> STRUCT System.Math[
	| System.Math.E ~> 2.71828182845905
	| System.Math.PI ~> 3.14159265358979
	| System.Math.doubleRoundLimit ~> 1E+16
	| System.Math.maxRoundingDigits ~> 15
	| System.Math.roundPower10Double ~> (HeapRef 1)]
VSharp.CSharpUtils.Tests.Arithmetics ==> STRUCT VSharp.CSharpUtils.Tests.Arithmetics[
	]

METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.Negation1()
RESULT: False
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.Negation1(System.Int32)
RESULT: False
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.Negation2(System.Boolean)
RESULT: !b
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.Negation3(System.Boolean)
RESULT: b
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.Negation4(System.Boolean)
RESULT: b
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.Negation5(System.Boolean)
RESULT: b
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.And1(System.Boolean, System.Boolean)
RESULT: a
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.And2(System.Boolean, System.Boolean)
RESULT: False
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.And3(System.Boolean, System.Boolean)
RESULT: False
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.And4(System.Boolean, System.Boolean)
RESULT: True
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.And5(System.Boolean, System.Boolean)
RESULT: False
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.And6(System.Boolean, System.Boolean)
RESULT: False
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.And7(System.Boolean, System.Boolean)
RESULT: False
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.And8(System.Boolean, System.Boolean)
RESULT: a & b
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.And9(System.Boolean, System.Boolean, System.Boolean)
RESULT: False
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.Or1(System.Boolean, System.Boolean)
RESULT: True
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.Or2(System.Boolean, System.Boolean)
RESULT: True
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.Or3(System.Boolean, System.Boolean)
RESULT: False
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.Or4(System.Boolean, System.Boolean)
RESULT: True
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.Or5(System.Boolean, System.Boolean)
RESULT: True
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.Or6(System.Boolean, System.Boolean)
RESULT: True
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.Or7(System.Boolean, System.Boolean)
RESULT: True
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.Or8(System.Boolean, System.Boolean)
RESULT: a | b
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.Or9(System.Boolean, System.Boolean, System.Boolean)
RESULT: True
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.Or10(System.Boolean, System.Boolean, System.Boolean)
RESULT: a | b
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.AndOr0(System.Boolean, System.Boolean, System.Boolean)
RESULT: False
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.AndOr1(System.Boolean, System.Boolean, System.Boolean)
RESULT: b & c
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.AndOr2(System.Boolean, System.Boolean, System.Boolean)
RESULT: !b & c
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.AndOr3(System.Boolean, System.Boolean, System.Boolean)
RESULT: b | c
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.AndOr4(System.Boolean, System.Boolean, System.Boolean)
RESULT: !b | c
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.AndOr5(System.Boolean, System.Boolean, System.Boolean)
RESULT: a & b & c
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.AndOr6(System.Boolean, System.Boolean, System.Boolean)
RESULT: !a & b | a & c
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.AndOr7(System.Boolean, System.Boolean, System.Boolean)
RESULT: (a | b) & (a | c)
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.AndOr8(System.Boolean, System.Boolean, System.Boolean)
RESULT: a & b | a & c
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.AndOr9(System.Boolean, System.Boolean, System.Boolean)
RESULT: (a | b) & (a | c)
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.AndOr10(System.Boolean, System.Boolean, System.Boolean)
RESULT: a & b | a & c
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.AndOr11(System.Boolean, System.Boolean, System.Boolean, System.Boolean)
RESULT: !a | !b | !c | d
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.AndOr12(System.Boolean, System.Boolean, System.Boolean, System.Boolean)
RESULT: !a & (!a & b | a & c)
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.AndOr13(System.Boolean, System.Boolean, System.Boolean, System.Boolean)
RESULT: True
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.AndOr14(System.Boolean, System.Boolean, System.Boolean, System.Boolean)
RESULT: !a & b
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.AndOr15(System.Boolean, System.Boolean, System.Boolean, System.Boolean)
RESULT: (!a | !b) & c
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.AndOr16(System.Boolean, System.Boolean, System.Boolean, System.Boolean)
RESULT: !b | a | c
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.AndOr17(System.Boolean, System.Boolean, System.Boolean, System.Boolean)
RESULT: !b & a | (!b | !c) & a | a & c
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.AndOr18(System.Boolean, System.Boolean, System.Boolean, System.Boolean)
RESULT: !c | (!a | b) & (!b & a | c)
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.AndOr19(System.Boolean, System.Boolean, System.Boolean, System.Boolean)
RESULT: a & b
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.AndOr20(System.Boolean, System.Boolean, System.Boolean, System.Boolean)
RESULT: a
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.AndOr21(System.Boolean, System.Boolean, System.Boolean, System.Boolean)
RESULT: !a & b
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.AndOr22(System.Boolean, System.Boolean, System.Boolean, System.Boolean)
RESULT: !b & a
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.AndOr23(System.Boolean, System.Boolean, System.Boolean, System.Boolean)
RESULT: !a & b
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.AndOr24(System.Boolean, System.Boolean, System.Boolean, System.Boolean)
RESULT: (!a | !b | !c) & (!a | b) & (!c | a)
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.AndOr25(System.Boolean, System.Boolean, System.Boolean, System.Boolean)
RESULT: a
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.Xor1(System.Boolean, System.Boolean, System.Boolean, System.Boolean)
RESULT: False
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.Xor2(System.Boolean, System.Boolean, System.Boolean, System.Boolean)
RESULT: True
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.Xor3(System.Boolean, System.Boolean, System.Boolean, System.Boolean)
RESULT: (!a | !b) & (a | b)
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.Xor4(System.Boolean, System.Boolean, System.Boolean, System.Boolean)
RESULT: !a
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.Xor5(System.Boolean, System.Boolean, System.Boolean, System.Boolean)
RESULT: a
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.Xor6(System.Boolean, System.Boolean, System.Boolean, System.Boolean)
RESULT: True
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.Xor7(System.Boolean, System.Boolean, System.Boolean, System.Boolean)
RESULT: (!a | (!a & !b | !c | a & b) & ((!a | !b) & (a | b) | c)) & (!c & (!a & !b | a & b) | (!a | !b) & (a | b) & c | a)
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.Xor8(System.Boolean, System.Boolean, System.Boolean, System.Boolean)
RESULT: (!a & !b | a & b) & ((!a | !b) & (a | b) | (!a | !b) & (a | b))
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.CondAnd1(System.Int32)
RESULT: False
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.CondAnd2(System.Int32)
RESULT: False
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.CondAnd3(System.Int32)
RESULT: False
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.CondOr1(System.Int32)
RESULT: True
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.CondOr2(System.Int32)
RESULT: False
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.CondOr3(System.Int32)
RESULT: True
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.Equal1(System.Boolean, System.Boolean, System.Boolean, System.Boolean)
RESULT: True
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.Equal2(System.Boolean, System.Boolean, System.Boolean, System.Boolean)
RESULT: !a & !b | a & b
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.Equal3(System.Boolean, System.Boolean, System.Boolean, System.Boolean)
RESULT: True
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.NotEqual1(System.Boolean, System.Boolean, System.Boolean, System.Boolean)
RESULT: !a & b | !b & a
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.NotEqual2(System.Boolean, System.Boolean, System.Boolean, System.Boolean)
RESULT: False
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.Order1(System.Boolean, System.Boolean, System.Boolean, System.Boolean)
RESULT: a & b & c
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.Order2(System.Boolean, System.Boolean, System.Boolean, System.Boolean)
RESULT: a & b & c
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.Order3(System.Int32, System.Int32, System.Int32, System.Int32)
RESULT: -b + a + -c == 0
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Logics.Order4(System.Int32, System.Int32, System.Int32, System.Int32)
RESULT: -b + a + -c == 0
HEAP:
VSharp.CSharpUtils.Tests.Logics ==> STRUCT VSharp.CSharpUtils.Tests.Logics[
	]
METHOD: System.Void VSharp.CSharpUtils.Tests.A.IncN()
RESULT: <VOID>
HEAP:
1 ==> STRUCT VSharp.CSharpUtils.Tests.A[
	| VSharp.CSharpUtils.Tests.A._b ~> STRUCT VSharp.CSharpUtils.Tests.B[
		| VSharp.CSharpUtils.Tests.B._c ~> STRUCT VSharp.CSharpUtils.Tests.C[
			| VSharp.CSharpUtils.Tests.C.<M1>k__BackingField ~> VSharp.CSharpUtils.Tests.C.<M1>k__BackingField
			| VSharp.CSharpUtils.Tests.C._m2 ~> VSharp.CSharpUtils.Tests.C._m2
			| VSharp.CSharpUtils.Tests.C._n ~> 1 + VSharp.CSharpUtils.Tests.C._n]]
	| VSharp.CSharpUtils.Tests.A._intField ~> VSharp.CSharpUtils.Tests.A._intField]
VSharp.CSharpUtils.Tests.A ==> STRUCT VSharp.CSharpUtils.Tests.A[
	]
VSharp.CSharpUtils.Tests.B ==> STRUCT VSharp.CSharpUtils.Tests.B[
	]
VSharp.CSharpUtils.Tests.C ==> STRUCT VSharp.CSharpUtils.Tests.C[
	]
METHOD: System.Void VSharp.CSharpUtils.Tests.A.DecN()
RESULT: <VOID>
HEAP:
1 ==> STRUCT VSharp.CSharpUtils.Tests.A[
	| VSharp.CSharpUtils.Tests.A._b ~> STRUCT VSharp.CSharpUtils.Tests.B[
		| VSharp.CSharpUtils.Tests.B._c ~> STRUCT VSharp.CSharpUtils.Tests.C[
			| VSharp.CSharpUtils.Tests.C.<M1>k__BackingField ~> VSharp.CSharpUtils.Tests.C.<M1>k__BackingField
			| VSharp.CSharpUtils.Tests.C._m2 ~> VSharp.CSharpUtils.Tests.C._m2
			| VSharp.CSharpUtils.Tests.C._n ~> -1 + VSharp.CSharpUtils.Tests.C._n]]
	| VSharp.CSharpUtils.Tests.A._intField ~> VSharp.CSharpUtils.Tests.A._intField]
VSharp.CSharpUtils.Tests.A ==> STRUCT VSharp.CSharpUtils.Tests.A[
	]
VSharp.CSharpUtils.Tests.B ==> STRUCT VSharp.CSharpUtils.Tests.B[
	]
VSharp.CSharpUtils.Tests.C ==> STRUCT VSharp.CSharpUtils.Tests.C[
	]
METHOD: System.Int32 VSharp.CSharpUtils.Tests.A.GetN()
RESULT: VSharp.CSharpUtils.Tests.C._n
HEAP:
1 ==> STRUCT VSharp.CSharpUtils.Tests.A[
	| VSharp.CSharpUtils.Tests.A._b ~> STRUCT VSharp.CSharpUtils.Tests.B[
		| VSharp.CSharpUtils.Tests.B._c ~> STRUCT VSharp.CSharpUtils.Tests.C[
			| VSharp.CSharpUtils.Tests.C.<M1>k__BackingField ~> VSharp.CSharpUtils.Tests.C.<M1>k__BackingField
			| VSharp.CSharpUtils.Tests.C._m2 ~> VSharp.CSharpUtils.Tests.C._m2
			| VSharp.CSharpUtils.Tests.C._n ~> VSharp.CSharpUtils.Tests.C._n]]
	| VSharp.CSharpUtils.Tests.A._intField ~> VSharp.CSharpUtils.Tests.A._intField]
VSharp.CSharpUtils.Tests.A ==> STRUCT VSharp.CSharpUtils.Tests.A[
	]
VSharp.CSharpUtils.Tests.B ==> STRUCT VSharp.CSharpUtils.Tests.B[
	]
VSharp.CSharpUtils.Tests.C ==> STRUCT VSharp.CSharpUtils.Tests.C[
	]
METHOD: System.Int32 VSharp.CSharpUtils.Tests.B.GetN()
RESULT: VSharp.CSharpUtils.Tests.C._n
HEAP:
1 ==> STRUCT VSharp.CSharpUtils.Tests.B[
	| VSharp.CSharpUtils.Tests.B._c ~> STRUCT VSharp.CSharpUtils.Tests.C[
		| VSharp.CSharpUtils.Tests.C.<M1>k__BackingField ~> VSharp.CSharpUtils.Tests.C.<M1>k__BackingField
		| VSharp.CSharpUtils.Tests.C._m2 ~> VSharp.CSharpUtils.Tests.C._m2
		| VSharp.CSharpUtils.Tests.C._n ~> VSharp.CSharpUtils.Tests.C._n]]
VSharp.CSharpUtils.Tests.B ==> STRUCT VSharp.CSharpUtils.Tests.B[
	]
VSharp.CSharpUtils.Tests.C ==> STRUCT VSharp.CSharpUtils.Tests.C[
	]
METHOD: System.Void VSharp.CSharpUtils.Tests.B.SetN(System.Int32)
RESULT: <VOID>
HEAP:
1 ==> STRUCT VSharp.CSharpUtils.Tests.B[
	| VSharp.CSharpUtils.Tests.B._c ~> STRUCT VSharp.CSharpUtils.Tests.C[
		| VSharp.CSharpUtils.Tests.C.<M1>k__BackingField ~> VSharp.CSharpUtils.Tests.C.<M1>k__BackingField
		| VSharp.CSharpUtils.Tests.C._m2 ~> VSharp.CSharpUtils.Tests.C._m2
		| VSharp.CSharpUtils.Tests.C._n ~> n]]
VSharp.CSharpUtils.Tests.B ==> STRUCT VSharp.CSharpUtils.Tests.B[
	]
METHOD: System.Int32 VSharp.CSharpUtils.Tests.C.get_M2()
RESULT: VSharp.CSharpUtils.Tests.C._m2
HEAP:
1 ==> STRUCT VSharp.CSharpUtils.Tests.C[
	| VSharp.CSharpUtils.Tests.C.<M1>k__BackingField ~> VSharp.CSharpUtils.Tests.C.<M1>k__BackingField
	| VSharp.CSharpUtils.Tests.C._m2 ~> VSharp.CSharpUtils.Tests.C._m2
	| VSharp.CSharpUtils.Tests.C._n ~> VSharp.CSharpUtils.Tests.C._n]
VSharp.CSharpUtils.Tests.C ==> STRUCT VSharp.CSharpUtils.Tests.C[
	]
METHOD: System.Void VSharp.CSharpUtils.Tests.C.set_M2(System.Int32)
RESULT: <VOID>
HEAP:
1 ==> STRUCT VSharp.CSharpUtils.Tests.C[
	| VSharp.CSharpUtils.Tests.C.<M1>k__BackingField ~> VSharp.CSharpUtils.Tests.C.<M1>k__BackingField
	| VSharp.CSharpUtils.Tests.C._m2 ~> value
	| VSharp.CSharpUtils.Tests.C._n ~> VSharp.CSharpUtils.Tests.C._n]
VSharp.CSharpUtils.Tests.C ==> STRUCT VSharp.CSharpUtils.Tests.C[
	]
METHOD: System.Int32 VSharp.CSharpUtils.Tests.C.get_M1()
RESULT: VSharp.CSharpUtils.Tests.C.<M1>k__BackingField
HEAP:
1 ==> STRUCT VSharp.CSharpUtils.Tests.C[
	| VSharp.CSharpUtils.Tests.C.<M1>k__BackingField ~> VSharp.CSharpUtils.Tests.C.<M1>k__BackingField
	| VSharp.CSharpUtils.Tests.C._m2 ~> VSharp.CSharpUtils.Tests.C._m2
	| VSharp.CSharpUtils.Tests.C._n ~> VSharp.CSharpUtils.Tests.C._n]
VSharp.CSharpUtils.Tests.C ==> STRUCT VSharp.CSharpUtils.Tests.C[
	]
METHOD: System.Void VSharp.CSharpUtils.Tests.C.set_M1(System.Int32)
RESULT: <VOID>
HEAP:
1 ==> STRUCT VSharp.CSharpUtils.Tests.C[
	| VSharp.CSharpUtils.Tests.C.<M1>k__BackingField ~> value
	| VSharp.CSharpUtils.Tests.C._m2 ~> VSharp.CSharpUtils.Tests.C._m2
	| VSharp.CSharpUtils.Tests.C._n ~> VSharp.CSharpUtils.Tests.C._n]
VSharp.CSharpUtils.Tests.C ==> STRUCT VSharp.CSharpUtils.Tests.C[
	]
METHOD: System.Void VSharp.CSharpUtils.Tests.C.SetN(System.Int32)
RESULT: <VOID>
HEAP:
1 ==> STRUCT VSharp.CSharpUtils.Tests.C[
	| VSharp.CSharpUtils.Tests.C.<M1>k__BackingField ~> 42
	| VSharp.CSharpUtils.Tests.C._m2 ~> 102
	| VSharp.CSharpUtils.Tests.C._n ~> n]
VSharp.CSharpUtils.Tests.C ==> STRUCT VSharp.CSharpUtils.Tests.C[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.ClassesSimple.Test1(System.Int32)
RESULT: True
HEAP:
1 ==> STRUCT VSharp.CSharpUtils.Tests.A[
	| VSharp.CSharpUtils.Tests.A._b ~> STRUCT VSharp.CSharpUtils.Tests.B[
		| VSharp.CSharpUtils.Tests.B._c ~> STRUCT VSharp.CSharpUtils.Tests.C[
			| VSharp.CSharpUtils.Tests.C.<M1>k__BackingField ~> 42
			| VSharp.CSharpUtils.Tests.C._m2 ~> 102
			| VSharp.CSharpUtils.Tests.C._n ~> n]]
	| VSharp.CSharpUtils.Tests.A._intField ~> 100500]
VSharp.CSharpUtils.Tests.A ==> STRUCT VSharp.CSharpUtils.Tests.A[
	]
VSharp.CSharpUtils.Tests.B ==> STRUCT VSharp.CSharpUtils.Tests.B[
	]
VSharp.CSharpUtils.Tests.C ==> STRUCT VSharp.CSharpUtils.Tests.C[
	]
VSharp.CSharpUtils.Tests.ClassesSimple ==> STRUCT VSharp.CSharpUtils.Tests.ClassesSimple[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Conditional.IsMaxEven(System.Int32, System.Int32, System.Int32)
RESULT: !(2 * x < 2 * y) & !(2 * y < z) | !(2 * x < z) & 2 * y < z | !(2 * y < z) & (!(2 * y < z) & 2 * x < 2 * y | 2 * x < z & 2 * y < z) | (!(2 * y < z) & 2 * x < 2 * y | 2 * x < z & 2 * y < z) & 0 == z % 2 & 2 * y < z
HEAP:
1 ==> [| 0: 1; 1: 10; 10: 10000000000; 11: 100000000000; 12: 1000000000000; 13: 10000000000000; 14: 100000000000000; 15: 1E+15; 2: 100; 3: 1000; 4: 10000; 5: 100000; 6: 1000000; 7: 10000000; 8: 100000000; 9: 1000000000 ... 16 ... |]
System.Math ==> STRUCT System.Math[
	| System.Math.E ~> 2.71828182845905
	| System.Math.PI ~> 3.14159265358979
	| System.Math.doubleRoundLimit ~> 1E+16
	| System.Math.maxRoundingDigits ~> 15
	| System.Math.roundPower10Double ~> (HeapRef 1)]
VSharp.CSharpUtils.Tests.Conditional ==> STRUCT VSharp.CSharpUtils.Tests.Conditional[
	]
METHOD: System.Int32 VSharp.CSharpUtils.Tests.Conditional.Always18()
RESULT: 18
HEAP:
VSharp.CSharpUtils.Tests.Conditional ==> STRUCT VSharp.CSharpUtils.Tests.Conditional[
	]
METHOD: System.Int32 VSharp.CSharpUtils.Tests.Conditional.EnsureAlwaysN(System.Int32)
RESULT: n
HEAP:
VSharp.CSharpUtils.Tests.Conditional ==> STRUCT VSharp.CSharpUtils.Tests.Conditional[
	]
METHOD: System.Int32 VSharp.CSharpUtils.Tests.Conditional.FirstEvenGreaterThen7()
RESULT: 8
HEAP:
VSharp.CSharpUtils.Tests.Conditional ==> STRUCT VSharp.CSharpUtils.Tests.Conditional[
	]
METHOD: System.Int32 VSharp.CSharpUtils.Tests.Fibonacci.Fib2()
RESULT: 2
HEAP:
VSharp.CSharpUtils.Tests.Fibonacci ==> STRUCT VSharp.CSharpUtils.Tests.Fibonacci[
	]
METHOD: System.Int32 VSharp.CSharpUtils.Tests.Fibonacci.Fib5()
RESULT: 8
HEAP:
VSharp.CSharpUtils.Tests.Fibonacci ==> STRUCT VSharp.CSharpUtils.Tests.Fibonacci[
	]
METHOD: System.Int32 VSharp.CSharpUtils.Tests.GCD.Gcd1()
RESULT: 1
HEAP:
VSharp.CSharpUtils.Tests.GCD ==> STRUCT VSharp.CSharpUtils.Tests.GCD[
	]
METHOD: System.Int32 VSharp.CSharpUtils.Tests.GCD.Gcd15()
RESULT: 15
HEAP:
VSharp.CSharpUtils.Tests.GCD ==> STRUCT VSharp.CSharpUtils.Tests.GCD[
	]
METHOD: System.Int32 VSharp.CSharpUtils.Tests.Lambdas.Always18()
RESULT: 18
HEAP:
1 ==> <Lambda Expression int32 -> object>
VSharp.CSharpUtils.Tests.Lambdas ==> STRUCT VSharp.CSharpUtils.Tests.Lambdas[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Tests.Lambdas.DoubleValue(System.Int32, System.Boolean)
RESULT: True
HEAP:
1 ==> <Lambda Expression int32 -> object>
2 ==> <Lambda Expression int32 -> object>
VSharp.CSharpUtils.Tests.Lambdas ==> STRUCT VSharp.CSharpUtils.Tests.Lambdas[
	]

METHOD: System.Boolean VSharp.CSharpUtils.Tests.Conditional.TestSwitch(System.Char)
RESULT: UNION[
	| !(A == c) & !(B == c) & !(C == c) & !(D == c) & !(R == c) & T == c ~> <ERROR: (HeapRef 1)>
	| !(T == c) | A == c | B == c | C == c | D == c | R == c ~> (!(B == c) & !(C == c) & !(D == c) & !(R == c) & A == c & T == c | !(B == c) & !(C == c) & !(D == c) & A == c & R == c | !(C == c) & !(D == c) & !(R == c) & B == c & T == c | !(C == c) & !(D == c) & B == c & R == c | !(D == c) & !(R == c) & C == c & T == c | !(D == c) & C == c & R == c | !(R == c) & !(T == c) | !(R == c) & D == c & T == c | D == c & R == c) & (!(R == c) & !(T == c) | !(R == c) & <VOID> < 5 & T == c | <VOID> < 5 & R == c | A == c | B == c | C == c | D == c)]
HEAP:
1 ==> STRUCT System.ArgumentException[
	| System.ArgumentException.m_paramName ~> null
	| System.Exception._HResult ~> -2147024809
	| System.Exception._className ~> null
	| System.Exception._data ~> null
	| System.Exception._dynamicMethods ~> null
	| System.Exception._helpURL ~> null
	| System.Exception._innerException ~> null
	| System.Exception._message ~> null
	| System.Exception._remoteStackIndex ~> 0
	| System.Exception._remoteStackTraceString ~> null
	| System.Exception._safeSerializationManager ~> null
	| System.Exception._source ~> null
	| System.Exception._stackTrace ~> null
	| System.Exception._stackTraceString ~> null
	| System.Exception.captured_traces ~> null
	| System.Exception.native_trace_ips ~> null]
2 ==> STRUCT System.Object[
	]
System.ArgumentException ==> STRUCT System.ArgumentException[
	]
System.Exception ==> STRUCT System.Exception[
	| System.Exception._COMPlusExceptionCode ~> -532462766
	| System.Exception.s_EDILock ~> (HeapRef 2)]
System.Object ==> STRUCT System.Object[
	]
VSharp.CSharpUtils.Tests.Conditional ==> STRUCT VSharp.CSharpUtils.Tests.Conditional[
	]
METHOD: System.Boolean VSharp.CSharpUtils.Lists.Construct()
RESULT: True
HEAP:
1 ==> STRUCT VSharp.CSharpUtils.Lists[
	]
2 ==> [|  ... 0 ... |]
3 ==> STRUCT System.Collections.Generic.List`1[T][
	| System.Collections.Generic.List`1._items ~> (HeapRef 5)
	| System.Collections.Generic.List`1._size ~> 4
	| System.Collections.Generic.List`1._syncRoot ~> null
	| System.Collections.Generic.List`1._version ~> 4]
4 ==> [|  ... 4 ... |]
5 ==> [| 0: 1; 1: 2; 2: 3; 3: 4 ... 4 ... |]
6 ==> [|  ... 4 x 1 ... |]
7 ==> [| 0: 5; 1: 6; 2: 7; 3: 8 ... 4 ... |]
System.Array ==> STRUCT System.Array[
	]
System.Collections.Generic.List`1 ==> STRUCT System.Collections.Generic.List`1[T][
	| System.Collections.Generic.List`1._defaultCapacity ~> 4
	| System.Collections.Generic.List`1._emptyArray ~> (HeapRef 2)]
VSharp.CSharpUtils.Lists ==> STRUCT VSharp.CSharpUtils.Lists[
	]
METHOD: System.Int32 VSharp.CSharpUtils.Tests.Fibonacci.FibUnbound(System.Int32)
RESULT: VSharp.CSharpUtils.Tests.Fibonacci.b4
HEAP:
VSharp.CSharpUtils.Tests.Fibonacci ==> STRUCT VSharp.CSharpUtils.Tests.Fibonacci[
	| VSharp.CSharpUtils.Tests.Fibonacci.a ~> VSharp.CSharpUtils.Tests.Fibonacci.a4
	| VSharp.CSharpUtils.Tests.Fibonacci.b ~> VSharp.CSharpUtils.Tests.Fibonacci.b4]
